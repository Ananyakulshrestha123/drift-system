1. Client Agent (CA-IS-RLA)

The Client Agent acts as the **Data Assurance and Recovery Manager**. Its primary job is to ensure that every batch of data leaves the client and is successfully verified by the server.

### Key Roles and Functions

* **Integrity Generation:** When event data arrives, the CA first generates a cryptographic signature, the **Merkle Root Client ($\text{MR}_{\text{Client}}$)**, which uniquely represents the content and order of the entire batch.
* **Persistent Caching:** Before sending the data to the server (via the HEC), the CA stores a copy of the batch locally in its **cache**. This copy is held indefinitely.
* **Intelligent Self-Healing ($\text{IS-RLA}$):** The CA ignores the immediate, unreliable *HTTP success codes* from the HEC. It only waits for the final, definitive **SUCCESS** or **FAILURE Instruction** from the SA.
    * If **SUCCESS** is received, the batch is deleted from the cache.
    * If **FAILURE** is received, the CA retrieves the batch from the cache and uses its **Intelligent Resend Strategy** (an RL policy) to decide the optimal time to resubmit the data, preventing immediate data loss and server overload.

***

## 2. Server Agent (SA-IS-RLA)

The Server Agent is the **Integrity Validator and Decision Maker**. It sits between the data ingress point (HEC) and the final Indexing System. It is the only agent that makes integrity-critical decisions.

### Key Roles and Functions

* **Proactive Intelligence ($\text{IS-RLA}$):** The SA observes the current state of the Indexing System ($S_{\text{Server}}$). Using its $\text{IS-RLA}$ policy, it can **proactively reject** a batch (by sending a FAILURE Instruction to the CA) if it predicts the indexing will fail due to system load or instability, preventing wasted processing time.
* **Data Verification:** After the events are processed by the indexer, the SA calculates its own signature, the **Merkle Root Server ($\text{MR}_{\text{Server}}$)**, from the data as it was *actually indexed*. It also calculates the event hashes ($\text{H}'$) needed for duplication checks.
* **Final Integrity Check:** The SA performs two critical checks:
    1.  **Duplication Check:** Queries the BA to ensure the event hashes ($\text{H}'$) have not been logged before (preventing chronological duplication).
    2.  **Corruption Check:** Compares the client's signature with its own: $\mathbf{MR}_{\text{Server}} \stackrel{?}{=} \mathbf{MR}_{\text{Client}}$.
* **Verdict Communication:** Based on these checks, the SA issues the final **SUCCESS** (if all checks pass) or **FAILURE** (if corruption, duplication, or pre-emptive rejection occurs) instruction back to the CA.
* **Logging to BA:** The SA logs the final verdict (SUCCESS or FAILURE) and the related cryptographic hashes to the BA.

***

## 3. Blockchain Agent (BA)

The Blockchain Agent is the **Immutable Audit Log and Single Source of Truth**. Its role is passive and focused entirely on ensuring the long-term integrity and auditability of the indexing process.

### Key Roles and Functions

* **Immutable Ledger:** The BA stores every final verdict from the SA (SUCCESS or FAILURE) in a chronologically chained ledger (using Merkle Trees or hash chaining). This ledger is tamper-proof.
* **Status Non-Expiry (Issue Resolution):** Because the final verdict is stored on this permanent ledger, the status of any indexed batch **never expires**, resolving the issue of lost or aged status information.
* **Duplication Service:** It provides a query service to the SA. The SA asks, "Has this hash ($\text{H}'$) ever been successfully indexed?" The BA's simple, immutable response resolves the issue of **chronological duplication**.
* **Non-Repudiation:** The ledger serves as the official, auditable record for compliance, proving that the SA made a specific decision (SUCCESS/FAILURE) at a specific time based on the data provided.
